---
title: "[Note] 25-01-20 noLinux.txt"
categories: [Notepad, Daily]
tags: 
date: 2025-01-20 21:49:00 +0900
comments: false
---
---

## WinFuzz [USENIX '23]

https://www.usenix.org/conference/usenixsecurity23/presentation/stone

# windows 퍼징에 대한 백그라운드 쏘굿

##멋진말
- Windows 퍼징 작업은 Linux 퍼저 [41], [42], [43], [44]의 발전을 통합하고 있지만, 
  Linux 기반 실행 메커니즘을 Windows로 안정적으로 포팅(portig)하는 것은 여전히 해결되지 않은 과제입니다. 

- 이러한 문제를 극복하기 위해 이 백서에서는 대상 임베디드 스냅샷의 개념, 즉 퍼징된 Windows 애플리케이션 자체를 스냅샷으로 만드는 기술을 소개한다. 
  이 접근 방식은 퍼징 관련 프로그램 상태(예: 스택, 전역)는 언어 수준 구조로만 제어할 수 있으므로 스냅샷의 책임을 커널에서 퍼징된 프로그램으로 옮길 수 있다는 통찰에 기반한다.
- 기존 실행 메커니즘의 설계 trade-off를 검토하여 효과적인 Windows 소프트웨어 퍼징을 지원하는 데 필요한 이상적인 특성에 대한 기준을 개발합니다.
- [Background] 이 섹션에서는 타겟 임베디드 스냅샷팅의 핵심 주제인 커버리지 기반 퍼징, 프로세스 실행 상태, 퍼징 프로세스 실행 메커니즘을 소개합니다.



##빌드업
커버리지 가이드 퍼징 = 가장 성공적인 접근 방식
퍼징에서는 속도가 가장 중요

고성능 퍼저는 프로세스 스냅샷(=커널 기반 스냅샷 기술)을 구현
= fuzzing-oriented execution primitives ???
- ★커널의 폐쇄 소스 특성(closed-source nature)으로 인해 현재 커널 기반 스냅샷 기술을 이식할 수 없으므로 Windows 프로그램에서 퍼징의 효과가 심각하게 제한됩니다.
--- 따라서 Windows 소프트웨어 생태계의 심사를 가속화하려면 빠르고 정확하며 커널과 무관한 퍼징 실행 메커니즘이 필요합니다.
	 --- 띠용, 윈도우는 커널과 무관한 퍼징 기술을 사용해야 한다? closed-source nature 때문에?

##WinFuzz의 솔루션
target-embedded snapshotting을 통해 커널 수준의 문제가 아닌 애플리케이션 수준의 문제로 상태 스냅샷을 만드는 것을 제안

target-embedded snapshotting은 바이너리 및 라이브러리 수준의 후킹을 결합하여 
애플리케이션이 소스 코드와 Windows 커널을 그대로 두고 스스로 스냅샷을 찍을 수 있도록 합니다.

= 퍼징된 Windows 애플리케이션 자체를 스냅샷으로 만드는 기술

--> 퍼징 관련 프로그램 상태(예: 스택, 전역, 힙)는 언어 수준 구조로만 제어할 수 있으므로 
스냅샷의 책임을 커널에서 퍼징된 프로그램으로 옮길 수 있다는 통찰에 기반하는 접근방식

--- 인메모리 루핑의 속도를 활용하되 테스트 케이스 사이에 프로그램 상태를 재설정하여 정확성 문제를 해결

--- 이전 접근 방식에서는 각 테스트 케이스에 대해 완전히 새로운 프로세스를 생성하거나 주문형 상태 복사를 위해 커널 지원을 사용했지만, 
  저희는 바이너리 수준에서 프로그램을 후킹하여 자체 상태를 추적하고 복원하는 데 중점을 둡니다. 

-------------
## Introduction
지난 10년 동안 커버리지 가이드 퍼징은 소프트웨어의 보안 취약점을 자동으로 발견하는 가장 인기 있고 성공적인 기법으로 자리 잡았습니다. 퍼징의 핵심은 1 ⃝대량의 무작위 테스트 케이스를 생성하고, 2 ⃝대상 프로그램에서 각각을 실행하여 코드 커버리지를 추적하고, 3 ⃝관찰된 동작(예: 코드 커버리지 및 충돌)에 따라 테스트 케이스를 분류하는 방식으로 작동하는 것입니다. 많은 학계와 업계의 발전으로 퍼징의 테스트 케이스 생성 [1], [2], [3] 및 분류 [4], [5], [6] 기능이 크게 향상되었습니다. 그러나 퍼징은 대량의 테스트 케이스가 있는 프로그램을 면밀히 조사하는 것을 목표로 하기 때문에 높은 성능, 즉 높은 테스트 케이스 처리량을 유지하는 것이 효과적인 퍼징을 위해 매우 중요합니다. 

연구에 따르면 테스트 케이스 실행과 코드 커버리지 추적은 퍼징의 가장 리소스 집약적인 단계이며[7], 많은 성공적인 퍼징 최적화는 커버리지 추적 수준에서 작동합니다[8, [9], [10], [11]. 커버리지 추적 오버헤드를 제거하는 데 성공하면 가장 중요한 프로세스 실행 메커니즘(즉, 각 테스트 케이스에 대한 프로세스 준비)이 현재 퍼징 속도를 제한하는 요소로 남게 됩니다[12], [13], [14]. 소프트웨어 퍼징을 효과적으로 수행하려면 실행 메커니즘이 두 가지 핵심 속성을 유지해야 합니다:

1) 효율성: 대상 코드(예: GUI 초기화) 또는 커널 코드(예: 가상 메모리 관리)의 재실행을 피해야 합니다. 이는 흥미롭지 않은 코드를 실행하는 데 소요되는 시간을 줄여 테스트 케이스 처리량을 증가시킵니다. 
2) 정확성: 이전 테스트 케이스의 수나 순서에 상관없이 의미적으로 올바른 실행을 보장합니다.이렇게 하면 오탐(예: 가짜 충돌) 및 오탐(예: 누락된 취약점) 가능성을 제거할 수 있습니다. 

## 리눅스 쪽 퍼징 동향★
최근 몇 년 동안 Linux 퍼징 커뮤니티는 느리지만 정확하지 않은 프로세스 실행 메커니즘(예: 포크-execure 및 AFL의 포크 서버 [15])을 포기하고 빠르고 정확한 프로세스 스냅샷을 선호하고 있습니다: 리눅스의 오픈 소스 ker-nel [16], [13], [17]로의 확장을 통해 구현된 퍼징 맞춤형 실행 프리미티브. 스냅샷은 오늘날 퍼징에서 가능한 가장 빠른 올바른 프로세스 실행을 나타내며[17], 소프트웨어 취약점을 신속하게 발견할 수 있도록 테스트 케이스 처리량을 몇 배나 높일 수 있습니다. 

## 윈도우의 한계점★
안타깝게도 스냅샷 가속 실행의 이점은 아직 Windows 소프트웨어 퍼징에서 나타나지 않았습니다. 
Windows 커널의 폐쇄형 소스 특성으로 인해 Linux 기반 스냅샷 프리미티브의 타사 포팅이 불가능하기 때문에 Windows 퍼저는 프로세스 생성(예: CreateProcess() [18])을 통한 가장 느린 실행에 의존할 수밖에 없습니다. 최근의 리버스 엔지니어링 노력으로 숨겨진 복사-쓰기 프로세스 복제 프리미티브가 노출되었지만[19], 버전별 특성으로 인해 이전 커널 및 최신 커널과 호환되지 않습니다[20]. 더 심각한 문제는 Windows에서 공개하지 않은 이유로 인해 기존 프로세스 생성 및 복제 메커니즘이 Linux에 비해 최대 1,000배 느리다는 것입니다 [21], [19]. 일부 퍼저는 더 빠른 인메모리 프로세스 루핑(예: WinAFL의 영구 모드[18])을 채택하고 있지만, 프로세스 상태를 재설정할 수 없기 때문에 의미적으로 부정확한 실행으로 이어져 가짜 충돌과 누락된 충돌을 모두 유발합니다. 모든 Windows 커널을 지원하는 빠르고 정확한 실행이 없으면 Windows 애플리케이션 퍼징은 계속 손상되어 세계 최대 컴퓨팅 에코시스템의 소프트웨어를 검사하려는 노력을 방해할 것입니다.

최근 Linux 퍼징 커뮤니티는 느린 "포크-execure 및 AFL의 포크 서버 [15]"를 포기하고 빠르고 정확한 프로세스 스냅샷을 선호:
오픈소스 커널 확장을 통해 구현된 퍼징 맞춤형 execution primitives [16], [13], [17]

[17] 스냅샷 방식은 오늘날 퍼징에서 가능한 가장 빠른 올바른 process execution 방식이다! 즉, 테스트 케이스 처리량을 몇 배나 높일 수 있다!

-------------
## Background

- 이전 Windows 퍼징 실행 메커니즘(예: 프로세스 생성, forkserver 기반 복제 및 지속 모드)

---- 퍼징 실행 메커니즘(fuzzing execution mechanisms)★은 프로세스 생성, 포크 서버 기반 복제, 인메모리 루핑, 커널 기반 스냅샷의 네 가지 유형이 있음

1) Process Creation
- Windows에서 지원하는 대표적인 프로그램 실행 기법
- 1) 대상 실행 파일을 새 하위 프로세스에 로드  2) 자식 프로세스를 초기화하고 코드 실행  3) 종료 시 자식 프로세스의 리소스를 해제하고 새로 들어오는 테스트 케이스를 기다림
- 생성된 각 테스트 케이스에 대해 프로세스 생성 단계가 수행됨
- Windows 3.1부터 프로세스 생성은 CreateProcess() API[39]를 통해 용이해졌음
- WinAFL [18], Manul [35], KillerBeez [36]와 같은 많은 Windows 퍼저가 프로세스 생성을 지원하거나 이에 의존합니다. 


2) Forkserver-based Cloning
- 1) 타깃을 한 번 로드하여 포크서버 프로세스 생성 2) 초기화 후 대상 서브루틴(예: main())을 계측하여 쓰기 시 복사 프로세스 복제를 수행 3) 각 테스트 케이스에 대해 새 자식을 포크하고 실행  4) 종료 시 자식 프로세스 리소스를 해제하고 3단계로 이동
- 대상 초기화를 한 번만 수행하면 포크서버 기반 복제는 테스트 케이스마다 초기화 루틴을 다시 실행하는 비용을 절약할 수 있음
- 포크서버에 필요한 카피온-쓰기 복제 프리미티브는 윈도우에서 직접 지원하지는 않지만, 
	[19]는 윈도우의 비공개 소스 커널에서 숨겨진 카피온-쓰기 복제 프리미티브를 리버스 엔지니어링할 수 있는 가능성을 밝혔음
	* [19], WINNIE : Fuzzing Windows Applications with Harness Synthesis and Fast Cloning, NDSS, 2021 ★

3) In-memory Looping
- 1) 대상을 한 번 로드하여 대상 서브루틴(예: main())을 루프로 감싸는 지속적 프로세스를 생성  2) 각 테스트 케이스에 대해 루프의 새 Execution 수행  3) 종료 시 2단계에서 루프의 항목으로 다시 이동
- 프로세스 생성 및 포크 서버 기반 실행과 달리 인메모리 루핑은 하나의 영구적인(종료되지 않는) 자식에서 실행하는 대신 프로세스 스폰을 방지합니다. 
이러한 기술(예: AFL의 지속 모드[14])은 퍼징 대상 서브루틴 주위에 루프를 삽입하고 각 루프 반복은 단일 테스트 케이스에 할당됩니다. 

- WinAFL [18], TinyAFL [37], Jackalope [38]와 같은 많은 Windows 퍼저는 인메모리 루핑을 지원하거나 이에 의존합니다. 


4) Kernel-based Snapshotting
최근의 최신 퍼저(예: AFL++ [14])는 실행 사이에 프로세스 상태가 재설정되는 인메모리 루핑의 확장인 스냅샷팅이라는 새로운 실행 기법을 활용하고 있습니다.
- 1) 대상을 한 번 로드하여 원하는 서브루틴(예: 메인())을 래핑된 루프에 담은 지속적 프로세스를 생성
- 2) 타겟이 초기화된 후 전체 프로세스 상태를 저장 3) 테스트를 위해 루프의 새로운 Execution 실행  4) 종료 시, 프로세스 상태를 재설정하고 단계 3으로 점프
- 기존의 노력은 커스텀 커널 확장을 통해 특화된 스냅샷 프리미티브를 구현하며, 
- 현재 모든 스냅샷 퍼저는 Linux 기반임(예: AFL++LKM 모드[17], Xuetal. [13], Zhaoetal. [16])★




-------------
Windows 프로그램에서 빠르고 효과적인 퍼징을 달성하는 것은 어려운 일입니다. Windows 퍼징에 내재된 과제를 살펴보고 
인기 있는 퍼저(표 1)에서 발견되는 기존 실행 메커니즘의 근본적인 한계인 """효율성, 정확성, 커널 호환성"""을 조사하여 
Windows 실행 메커니즘이 달성해야 하는 이상적인 설계 품질의 기준을 정리합니다.
	// 내가 하고싶은걸 다 해놨자나 럭키비키
	// 표1은 Execution Mechanism 기준의로 정리했음, 참고!

## 3.1. LimitationsofWindowsFuzzingExecution★


1) (효율성) The Inefficient: Process Creation and Cloning.
== Criterion 1: Efficient across the target program and kernel.

- 테스트 케이스 실행이 퍼저 런타임의 90% 이상을 차지하는 것으로 나타나[7], 퍼저의 실행 메커니즘의 효율성에 따라 속도가 달라지지만,
- 현재 윈도우 퍼저는 프로세스 생성 및 초기화의 높은 목표 및 커널 오버헤드로 인해 제한을 받습니다.
	- restricted by the high target and kernel overheads of process creation and initialization.
	- high target이 뭐임

- 프로세스 생성 시 전체 프로그램을 다시 실행하면 메모리 관리, 바이너리 로딩, 동적 연결, 라이브러리 초기화 및 모든 테스트 케이스에 대한 기타 대상별 시작 루틴 비용이 발생하므로 퍼징의 실행 메커니즘이 가장 느려집니다.

- forkserver 기반 복제는 미리 초기화된 대상 상태에서 테스트 사례를 실행한다는 점에서 프로세스 생성과 다르지만 
두 실행 메커니즘 모두 각 자식 프로세스를 생성할 때 호출되는 수많은 퍼징과 무관한 커널 프로시저로 인해 상당한 오버헤드 발생[13], [16].
	-- 예: 주소 공간 초기화, 프로세스 ID 할당, 리소스 복제, 복사 시 쓰기 지원을 위한 백그라운드 메모리 관리, OS 상태 업데이트

- 또한 forkserver 기반 복제는 여전히 프로세스 해체 비용이 발생합니다.더 나쁜 것은 윈도우 커널의 불투명한 메커니즘이 이러한 메커니즘의 기본 요소를 더욱 부풀려서 Linux에 비해 201,000배 이상 느리게 만듭니다 [19], [21].



2) (정확도) The Incorrect: In-memory Looping
== Criterion 2: Fully reset program state for correctness.

- 퍼징의 수많은 테스트 케이스 실행은 대상 프로그램의 스택, 레지스터, 힙 및 전역 상태를 지속적으로 변경합니다. 
- 대상 상태의 손상(예: 명령 포인터 덮어쓰기)은 일반적으로 크래시로 해결되며, 이는 퍼징이 메모리 안전 위반(예: 스택 버퍼 오버플로)을 발견했음을 나타내므로 퍼징 후 취약성 분류를 위해 테스트 케이스가 저장됩니다. 
- 그러나 실행 메커니즘에 의해 프로세스 상태(state)가 손상되면 오류를 유발하는 테스트 사례를 찾는다는 퍼징의 목표는 빠르게 무력화됩니다. 
	// 무슨 소린고...?
	// process state is corrupted by the execution mechanism -> 실행 메커니즘을 돌리면, 프로세스 state가 손상된다? 중간에 캐치 안돼?
	// 메모리 루핑의 경우, 테스트 케이스 간에 프로세스 상태를 재설정하지 않아서 오탐이 많이 발생한다고,,, [19] hmmmmmmmm ?.?
- 오늘날 인메모리 루핑은 가장 타겟 및 커널 효율적인 실행을 제공하지만 테스트 사례 사이의 프로세스 상태를 재설정하지 않아 오염된 힙과 전역 상태로 인한 오탐 충돌로 인해 퍼저를 압도합니다[19]. 

- 오픈 소스 퍼징 컨텍스트(예: OSS-Fuzz[40])에서 대상 프로그램을 수정하여 상태를 재설정하는 것은 쉽게 달성할 수 있지만, 
폐쇄 소스인 Windows 소프트웨어의 특성(제거, 난독화 또는 불투명한 실행 파일)으로 인해 필요한 역엔지니어링 및 바이너리 재작성이 불가능합니다. 
따라서 효과적인 Windows 퍼징을 지원하려면 실행 메커니즘이 올바른 실행을 유지해야 합니다. 
즉, 테스트 케이스 간에 프로세스 상태를 완전하고 자동으로 복원해야 합니다. ★



3) (커널 호환성) The Incompatible: Cloning and Kernel Snapshotting
== Criterion 3: Kernel-agnostic performance and effectiveness.

- Windows 커널의 폐쇄 소스 특성으로 인해 인기 있는 커널 기반 스냅샷 작업 [13], [16], [17]에서 사용하는 타사 실행 프리미티브를 추가할 수 없습니다.


Windows 퍼징 작업은 Linux 퍼저 [41], [42], [43], [44]의 발전을 통합하고 있지만, Linux 기반 실행 메커니즘을 Windows로 안정적으로 포팅하는 것은 여전히 해결되지 않은 과제입니다. Windows 커널의 폐쇄 소스 특성으로 인해 인기 있는 커널 기반 스냅샷 작업 [13], [16], [17]에서 사용하는 타사 실행 프리미티브를 추가할 수 없습니다. Jung 등 [19]은 독점 커널 구성 요소(즉, ntdll.dll, NtCreateUserProcess, CSRSS 하위 시스템)에서 숨겨진 카피온라이트 프리미티브를 역설계하여 Windows에 포크 서버 기반 실행 형태를 도입하는 반면, 이들의 기술은 궁극적으로 커널에 특화되어 있으며, Windows 10 v1809 빌드 17763.973 [20] 이후 공식적으로 지원되지 않습니다. 이는 커널이 업데이트되거나 이전 버전의 경우 확장 불가능한 수동 재툴링을 요구합니다. Windows 커널은 2015년 [45] 이후 10개 이상의 주요 업데이트가 발표되는 등 매년 중요한 변화를 계속함에 따라 계속 성장하는 Windows 소프트웨어 생태계 전반에 퍼징의 범위를 확장하려면 커널에 구애받지 않는 (fully kernel-agnostic) 실행 메커니즘이 필요합니다.

 [41], [42], [43], [44] - WinAFL 포크들임
 [13], [16], [17] - 인기 있는 커널 기반 스냅샷 작업
 - “On-demand-fork: a microsecond fork for memory-intensive and latency-sensitive applications,”
 - “AFL-Snapshot-LKM,”
 - “Designing New Operating Primitives to Improve Fuzzing Performance,”

[19] “WINNIE : Fuzzing Windows Applications with Harness Synthesis and Fast Cloning,” in Network and Distributed System Security Symposium, ser. NDSS, 2021.
★[19]의 한계점
 Jung 등 [19]은 독점 커널 구성 요소(즉, ntdll.dll, NtCreateUserProcess, CSRSS 하위 시스템)에서 숨겨진 카피온라이트 프리미티브를 역설계하여 Windows에 포크 서버 기반 실행 형태를 도입하는 반면, 이들의 기술은 궁극적으로 커널에 특화되어 있으며, Windows 10 v1809 빌드 17763.973 [20] 이후 공식적으로 지원되지 않습니다. 이는 커널이 업데이트되거나 이전 버전의 경우 확장 불가능한 수동 재툴링을 요구합니다.

---- 결론이:: "커널에 구애받지 않는 실행 메커니즘이 필요합니다."
	이렇게 가도 되나 나도? 이게 맞긴한데
	그럼 커널 퍼징이 아니라, Windows 퍼징으로 해야 하나?


[20] --- WINNIE의 깃헙인듯
“Winnie-AFL,” 2021. [Online]. Available: https://github.com/sslab-gatech/winnie
-- 버전별 특성으로 인해 이전 커널 및 최신 커널과 호환되지 않습니다


프로세스 생성은 Windows의 표준 프리미티브를 통해 쉽게 지원되지만, 테스트 케이스별로 타겟 초기화 및 커널 북키핑 절차를 재실행하면 퍼징의 처리량이 빠르게 저하됩니다. 포크 서버 기반 복제는 타겟 재초기화를 피함으로써 더 빠른 속도를 보이지만, 프로세스 생성과 동일한 많은 무거운 커널 비용을 지불하여 전체 성능이 낮습니다. 인메모리 루프는 가장 적은 침습적 실행을 제공하지만, 테스트 케이스 간의 프로세스 상태를 재설정하지 못하면 가짜 충돌 및 잘못된 실행 동작으로 인해 퍼징이 지연됩니다. 스냅샷 생성은 속도와 정확성의 최상의 절충점을 나타내지만, Windows 커널의 폐쇄 소스 특성으로 인해 이와 포크 서버 기반 복제는 현대의 Windows 시스템과 대체로 호환되지 않습니다. 효율적이고 정확하며 완전히 호환되는 Windows 실행 메커니즘의 부족으로 인해 Windows 소프트웨어 퍼징은 Linux 시스템보다 몇 배 느리고 덜 효과적입니다.





## 본 논문에서 언급된 Windows 퍼저
WinAFL [18], Manul [35], KillerBeez [36] --- Process Creation
WINNIE [19] ----  Forkserver-based Cloning
WinAFL [18], TinyAFL [37], Jackalope [38] --- In-memory Looping

-- 현재 모든 스냅샷 퍼저는 Linux 기반임(예: AFL++LKM 모드[17], Xuetal. [13], Zhaoetal. [16])★

Windows 퍼징 작업은 Linux 퍼저 [41], [42], [43], [44]의 발전을 통합하고 있음
[41] R. Johnson, “WinAFL-IntelPT,” 2018. [Online]. Available: https: //github.com/intelpt/winafl-intelpt 
[42] M. B¨ ohme, “WinAFL Fast,” 2018. [Online]. Available: https: //github.com/mboehme/winaflfast 
[43] H. Shah, “WinAFL PowerMopt: WinAFL with mopt mutators and AFLFast power schedulers,” 2018. [Online]. Available: https: //github.com/hardik05/winafl-powermopt 
[44] M. Shudrak, “netafl: WinAFL patch to enable network-based apps fuzzing,” 2018. [Online]. Available: https://github.com/intelpt/ winafl-intelpt





